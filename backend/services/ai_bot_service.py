"""
Service de Bot IA Ultra Sophistiqu√© pour ShareYourSales

Fonctionnalit√©s:
- Assistant conversationnel intelligent (Claude/GPT-4)
- R√©ponses contextuelles bas√©es sur l'historique
- Support multilingue (FR, EN, AR)
- Int√©gration avec la base de donn√©es pour r√©ponses personnalis√©es
- Actions automatiques (cr√©er affiliation, v√©rifier stats, etc.)
- Analyse de sentiment
- Suggestions proactives
- Memory/Context management
- RAG (Retrieval-Augmented Generation) pour doc
"""

from typing import List, Dict, Optional, Tuple
from datetime import datetime, timedelta
from enum import Enum
import json
import httpx
import structlog
from dataclasses import dataclass, asdict
import re

logger = structlog.get_logger()


class BotLanguage(str, Enum):
    FRENCH = "fr"
    ENGLISH = "en"
    ARABIC = "ar"


class MessageRole(str, Enum):
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"


class IntentType(str, Enum):
    """Types d'intentions d√©tect√©es"""
    GREETING = "greeting"
    HELP = "help"
    CREATE_AFFILIATION = "create_affiliation"
    CHECK_STATS = "check_stats"
    CONNECT_SOCIAL = "connect_social"
    SUBSCRIPTION = "subscription"
    PAYMENT = "payment"
    COMPLAINT = "complaint"
    QUESTION = "question"
    GOODBYE = "goodbye"


@dataclass
class Message:
    """Message dans la conversation"""
    role: MessageRole
    content: str
    timestamp: datetime
    metadata: Optional[Dict] = None


@dataclass
class ConversationContext:
    """Contexte de la conversation"""
    user_id: str
    user_role: str  # influencer, merchant, admin
    language: BotLanguage
    messages: List[Message]
    user_data: Optional[Dict] = None
    session_id: Optional[str] = None


@dataclass
class BotAction:
    """Action √† ex√©cuter par le bot"""
    action_type: str
    parameters: Dict
    success: bool
    result: Optional[Dict] = None
    error: Optional[str] = None


class AIBotService:
    """
    Service principal du bot IA

    Architecture:
    1. Intent Detection - D√©tecte l'intention de l'utilisateur
    2. Context Enrichment - Enrichit avec donn√©es DB
    3. Response Generation - G√©n√®re r√©ponse via LLM
    4. Action Execution - Ex√©cute actions si n√©cessaire
    5. Memory Management - Sauvegarde contexte
    """

    def __init__(
        self,
        api_key: str = None,
        model: str = "claude-3-5-sonnet-20241022",
        max_context_messages: int = 20
    ):
        self.api_key = api_key
        self.model = model
        self.max_context_messages = max_context_messages

        # Intent patterns (regex)
        self.intent_patterns = {
            IntentType.GREETING: [
                r'\b(bonjour|salut|hello|hi|hey|salam)\b',
                r'\b(bonsoir|good morning|good evening)\b'
            ],
            IntentType.CREATE_AFFILIATION: [
                r'\b(cr√©er|g√©n√©rer|demander).{0,30}(lien|affiliation)\b',
                r'\b(create|generate).{0,30}(link|affiliation)\b',
                r'\b(je veux|i want).{0,30}(promouvoir|promote)\b'
            ],
            IntentType.CHECK_STATS: [
                r'\b(statistiques?|stats?|performances?)\b',
                r'\b(combien|how (much|many)).{0,30}(ventes?|sales?|commissions?)\b',
                r'\b(followers?|abonn√©s?|engagement)\b'
            ],
            IntentType.CONNECT_SOCIAL: [
                r'\b(connecter|connect|lier|link).{0,30}(instagram|tiktok|facebook)\b',
                r'\b(r√©seaux sociaux|social media)\b'
            ],
            IntentType.SUBSCRIPTION: [
                r'\b(abonnement|subscription|plan|pricing)\b',
                r'\b(upgrade|downgrade|cancel)\b'
            ],
            IntentType.PAYMENT: [
                r'\b(paiement|payment|payer|pay)\b',
                r'\b(retrait|withdraw|transfer)\b',
                r'\b(solde|balance|argent|money)\b'
            ],
            IntentType.COMPLAINT: [
                r'\b(probl√®me|problem|bug|erreur|error)\b',
                r'\b(ne fonctionne pas|doesn\'t work|broken)\b',
                r'\b(plainte|complaint|insatisfait)\b'
            ],
            IntentType.GOODBYE: [
                r'\b(au revoir|bye|goodbye|adieu|√† bient√¥t)\b',
                r'\b(merci|thank you|thanks)\b.*\b(bye|au revoir)\b'
            ]
        }

    async def chat(
        self,
        user_message: str,
        context: ConversationContext
    ) -> Tuple[str, Optional[BotAction]]:
        """
        M√©thode principale pour interagir avec le bot

        Args:
            user_message: Message de l'utilisateur
            context: Contexte de la conversation

        Returns:
            Tuple (r√©ponse du bot, action ex√©cut√©e)
        """
        try:
            # 1. D√©tecter l'intention
            intent = self._detect_intent(user_message, context.language)
            logger.info("intent_detected", intent=intent.value, user_id=context.user_id)

            # 2. Enrichir le contexte avec donn√©es DB
            enriched_context = await self._enrich_context(context)

            # 3. Ajouter le message utilisateur
            enriched_context.messages.append(Message(
                role=MessageRole.USER,
                content=user_message,
                timestamp=datetime.utcnow(),
                metadata={"intent": intent.value}
            ))

            # 4. Limiter historique conversation
            if len(enriched_context.messages) > self.max_context_messages:
                # Garder le message syst√®me + les N derniers messages
                system_msg = [m for m in enriched_context.messages if m.role == MessageRole.SYSTEM]
                recent_msgs = enriched_context.messages[-self.max_context_messages:]
                enriched_context.messages = system_msg + recent_msgs

            # 5. G√©n√©rer r√©ponse via LLM
            bot_response = await self._generate_response(
                enriched_context,
                intent
            )

            # 6. Ex√©cuter action si n√©cessaire
            action = await self._execute_action(
                intent,
                user_message,
                enriched_context
            )

            # 7. Ajouter r√©ponse bot √† l'historique
            enriched_context.messages.append(Message(
                role=MessageRole.ASSISTANT,
                content=bot_response,
                timestamp=datetime.utcnow(),
                metadata={"action": asdict(action) if action else None}
            ))

            # 8. Sauvegarder contexte
            await self._save_conversation(enriched_context)

            logger.info(
                "bot_response_generated",
                user_id=context.user_id,
                intent=intent.value,
                action_executed=action is not None
            )

            return bot_response, action

        except Exception as e:
            logger.error("bot_error", error=str(e), user_id=context.user_id)
            return self._get_error_response(context.language), None

    def _detect_intent(self, message: str, language: BotLanguage) -> IntentType:
        """
        D√©tecte l'intention de l'utilisateur via regex patterns

        Returns:
            IntentType d√©tect√©
        """
        message_lower = message.lower()

        # Parcourir tous les patterns
        for intent, patterns in self.intent_patterns.items():
            for pattern in patterns:
                if re.search(pattern, message_lower, re.IGNORECASE):
                    return intent

        # Par d√©faut: question g√©n√©rale
        return IntentType.QUESTION

    async def _enrich_context(self, context: ConversationContext) -> ConversationContext:
        """
        Enrichit le contexte avec donn√©es de la base de donn√©es

        R√©cup√®re:
        - Profil utilisateur
        - Statistiques r√©centes
        - Derni√®res affiliations
        - Solde/paiements
        """
        # TODO: Impl√©menter r√©cup√©ration DB
        # Pour l'instant, retourner contexte inchang√©

        # Exemple de ce qu'il faut r√©cup√©rer:
        # if context.user_role == "influencer":
        #     context.user_data = {
        #         "total_sales": 1250,
        #         "commission_earned": 375.50,
        #         "active_links": 5,
        #         "followers": 25000,
        #         "engagement_rate": 4.2,
        #         "pending_affiliations": 2
        #     }
        # elif context.user_role == "merchant":
        #     context.user_data = {
        #         "total_products": 15,
        #         "active_influencers": 8,
        #         "total_sales": 5600,
        #         "pending_requests": 3
        #     }

        return context

    async def _generate_response(
        self,
        context: ConversationContext,
        intent: IntentType
    ) -> str:
        """
        G√©n√®re la r√©ponse via LLM (Claude/GPT-4)

        Si pas d'API key, utilise r√©ponses pr√©-d√©finies
        """
        if not self.api_key:
            # Fallback: r√©ponses pr√©-d√©finies
            return self._get_predefined_response(intent, context)

        # Construire le prompt syst√®me
        system_prompt = self._build_system_prompt(context)

        # Construire l'historique de conversation
        messages = []
        for msg in context.messages:
            messages.append({
                "role": msg.role.value,
                "content": msg.content
            })

        try:
            # Appel √† l'API Claude (ou GPT-4)
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    "https://api.anthropic.com/v1/messages",
                    headers={
                        "x-api-key": self.api_key,
                        "anthropic-version": "2023-06-01",
                        "content-type": "application/json"
                    },
                    json={
                        "model": self.model,
                        "max_tokens": 1024,
                        "system": system_prompt,
                        "messages": messages
                    },
                    timeout=30.0
                )

                if response.status_code == 200:
                    data = response.json()
                    return data["content"][0]["text"]
                else:
                    logger.error("llm_api_error", status=response.status_code)
                    return self._get_predefined_response(intent, context)

        except Exception as e:
            logger.error("llm_generation_error", error=str(e))
            return self._get_predefined_response(intent, context)

    def _build_system_prompt(self, context: ConversationContext) -> str:
        """
        Construit le prompt syst√®me pour le LLM
        """
        role_instructions = {
            "influencer": """Vous √™tes un assistant IA expert en marketing d'affiliation, sp√©cialis√© dans l'aide aux influenceurs.
Vous aidez les influenceurs √†:
- Cr√©er des liens d'affiliation
- Optimiser leurs performances
- Comprendre leurs statistiques
- Connecter leurs r√©seaux sociaux
- Maximiser leurs commissions""",

            "merchant": """Vous √™tes un assistant IA expert en e-commerce et marketing d'affiliation.
Vous aidez les marchands √†:
- G√©rer leurs produits
- Recruter des influenceurs
- Analyser les performances
- Approuver les demandes d'affiliation
- Optimiser leur ROI""",

            "admin": """Vous √™tes un assistant IA pour les administrateurs de la plateforme ShareYourSales.
Vous aidez √†:
- Monitorer la plateforme
- G√©rer les utilisateurs
- Analyser les m√©triques globales
- R√©soudre les probl√®mes"""
        }

        base_prompt = f"""Tu es ShareBot, l'assistant intelligent de ShareYourSales.ma, la plateforme d'affiliation #1 au Maroc.

{role_instructions.get(context.user_role, role_instructions['influencer'])}

R√àGLES IMPORTANTES:
- R√©ponds TOUJOURS en {context.language.value.upper()} (fran√ßais si fr, anglais si en, arabe si ar)
- Sois concis, amical et professionnel
- Utilise des emojis occasionnellement pour rendre la conversation vivante
- Si tu ne sais pas, recommande de contacter le support
- Propose des actions concr√®tes (boutons, liens)
- Utilise les donn√©es utilisateur pour personnaliser les r√©ponses

DONN√âES UTILISATEUR:
{json.dumps(context.user_data or {}, indent=2, ensure_ascii=False)}

CAPACIT√âS:
- Cr√©er des demandes d'affiliation
- Afficher les statistiques en temps r√©el
- Guider pour connecter r√©seaux sociaux
- Expliquer le syst√®me de commission
- Aider √† r√©soudre des probl√®mes
"""
        return base_prompt

    def _get_predefined_response(
        self,
        intent: IntentType,
        context: ConversationContext
    ) -> str:
        """
        R√©ponses pr√©-d√©finies si pas d'API LLM disponible
        """
        lang = context.language

        responses = {
            IntentType.GREETING: {
                BotLanguage.FRENCH: f"üëã Bonjour! Je suis ShareBot, votre assistant intelligent ShareYourSales.\n\nComment puis-je vous aider aujourd'hui?",
                BotLanguage.ENGLISH: f"üëã Hello! I'm ShareBot, your ShareYourSales intelligent assistant.\n\nHow can I help you today?",
                BotLanguage.ARABIC: f"üëã ŸÖÿ±ÿ≠ÿ®ÿß! ÿ£ŸÜÿß ShareBotÿå ŸÖÿ≥ÿßÿπÿØŸÉ ÿßŸÑÿ∞ŸÉŸä ŸÅŸä ShareYourSales.\n\nŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿ≥ÿßÿπÿØÿ™ŸÉ ÿßŸÑŸäŸàŸÖÿü"
            },
            IntentType.HELP: {
                BotLanguage.FRENCH: """ü§ñ Je peux vous aider avec:

üìä **Statistiques** - V√©rifier vos ventes et commissions
üîó **Affiliation** - Cr√©er des liens d'affiliation
üì± **R√©seaux Sociaux** - Connecter Instagram, TikTok
üí∞ **Paiements** - V√©rifier votre solde
üì¶ **Produits** - Trouver des produits √† promouvoir

Que souhaitez-vous faire?""",
                BotLanguage.ENGLISH: """ü§ñ I can help you with:

üìä **Statistics** - Check your sales and commissions
üîó **Affiliation** - Create affiliation links
üì± **Social Media** - Connect Instagram, TikTok
üí∞ **Payments** - Check your balance
üì¶ **Products** - Find products to promote

What would you like to do?""",
                BotLanguage.ARABIC: """ü§ñ ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿ≥ÿßÿπÿØÿ™ŸÉ ŸÅŸä:

üìä **ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™** - ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ®Ÿäÿπÿßÿ™ŸÉ ŸàÿπŸÖŸàŸÑÿßÿ™ŸÉ
üîó **ÿßŸÑÿßŸÜÿ™ÿ≥ÿßÿ®** - ÿ•ŸÜÿ¥ÿßÿ° ÿ±Ÿàÿßÿ®ÿ∑ ÿßŸÑÿßŸÜÿ™ÿ≥ÿßÿ®
üì± **Ÿàÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™ŸàÿßÿµŸÑ** - ÿ±ÿ®ÿ∑ Instagram Ÿà TikTok
üí∞ **ÿßŸÑŸÖÿØŸÅŸàÿπÿßÿ™** - ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ±ÿµŸäÿØŸÉ
üì¶ **ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™** - ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ŸÖŸÜÿ™ÿ¨ÿßÿ™ ŸÑŸÑÿ™ÿ±ŸàŸäÿ¨

ŸÖÿßÿ∞ÿß ÿ™ÿ±ŸäÿØ ÿ£ŸÜ ÿ™ŸÅÿπŸÑÿü"""
            },
            IntentType.CHECK_STATS: {
                BotLanguage.FRENCH: f"""üìä **Vos Statistiques**

{self._format_stats(context)}

Voulez-vous plus de d√©tails sur une m√©trique sp√©cifique?""",
                BotLanguage.ENGLISH: f"""üìä **Your Statistics**

{self._format_stats(context)}

Would you like more details on a specific metric?"""
            },
            IntentType.CONNECT_SOCIAL: {
                BotLanguage.FRENCH: """üì± **Connexion R√©seaux Sociaux**

Connectez vos comptes pour:
‚úÖ Synchronisation automatique des stats
‚úÖ Profil plus attractif pour les marchands
‚úÖ Suivi de votre croissance

Plateformes disponibles:
‚Ä¢ Instagram
‚Ä¢ TikTok
‚Ä¢ Facebook

üëâ [Connecter mes r√©seaux sociaux](/influencer/social-media)""",
                BotLanguage.ENGLISH: """üì± **Social Media Connection**

Connect your accounts to:
‚úÖ Automatic stats synchronization
‚úÖ More attractive profile for merchants
‚úÖ Track your growth

Available platforms:
‚Ä¢ Instagram
‚Ä¢ TikTok
‚Ä¢ Facebook

üëâ [Connect my social media](/influencer/social-media)"""
            },
            IntentType.GOODBYE: {
                BotLanguage.FRENCH: "üëã √Ä bient√¥t! N'h√©sitez pas si vous avez d'autres questions.",
                BotLanguage.ENGLISH: "üëã See you soon! Don't hesitate if you have other questions.",
                BotLanguage.ARABIC: "üëã ÿ£ÿ±ÿßŸÉ ŸÇÿ±Ÿäÿ®ÿß! ŸÑÿß ÿ™ÿ™ÿ±ÿØÿØ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÑÿØŸäŸÉ ÿ£ÿ≥ÿ¶ŸÑÿ© ÿ£ÿÆÿ±Ÿâ."
            }
        }

        return responses.get(intent, {}).get(
            lang,
            responses[IntentType.HELP][BotLanguage.FRENCH]
        )

    def _format_stats(self, context: ConversationContext) -> str:
        """Formate les statistiques pour affichage"""
        if not context.user_data:
            return "Aucune donn√©e disponible pour le moment."

        if context.user_role == "influencer":
            data = context.user_data
            return f"""
üí∞ Commission gagn√©e: {data.get('commission_earned', 0)} MAD
üõçÔ∏è Ventes totales: {data.get('total_sales', 0)}
üîó Liens actifs: {data.get('active_links', 0)}
üë• Followers: {data.get('followers', 0):,}
üìà Taux d'engagement: {data.get('engagement_rate', 0)}%
"""
        else:
            data = context.user_data
            return f"""
üì¶ Produits: {data.get('total_products', 0)}
üë• Influenceurs actifs: {data.get('active_influencers', 0)}
üí∞ Ventes totales: {data.get('total_sales', 0)} MAD
‚è≥ Demandes en attente: {data.get('pending_requests', 0)}
"""

    async def _execute_action(
        self,
        intent: IntentType,
        message: str,
        context: ConversationContext
    ) -> Optional[BotAction]:
        """
        Ex√©cute une action si l'intention le requiert

        Actions possibles:
        - Cr√©er demande d'affiliation
        - R√©cup√©rer statistiques
        - Initier connexion r√©seaux sociaux
        """
        # Pour l'instant, pas d'actions automatiques
        # TODO: Impl√©menter actions r√©elles
        return None

    async def _save_conversation(self, context: ConversationContext):
        """
        Sauvegarde la conversation en base de donn√©es
        """
        # TODO: Impl√©menter sauvegarde DB
        pass

    def _get_error_response(self, language: BotLanguage) -> str:
        """R√©ponse en cas d'erreur"""
        errors = {
            BotLanguage.FRENCH: "üòî D√©sol√©, j'ai rencontr√© une erreur. Veuillez r√©essayer ou contacter le support.",
            BotLanguage.ENGLISH: "üòî Sorry, I encountered an error. Please try again or contact support.",
            BotLanguage.ARABIC: "üòî ÿπÿ∞ÿ±ÿßÿå Ÿàÿßÿ¨Ÿáÿ™ ÿÆÿ∑ÿ£. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿØÿπŸÖ."
        }
        return errors.get(language, errors[BotLanguage.FRENCH])


# ============================================
# FONCTIONS UTILITAIRES
# ============================================

def create_conversation_context(
    user_id: str,
    user_role: str,
    language: str = "fr"
) -> ConversationContext:
    """
    Cr√©e un nouveau contexte de conversation
    """
    return ConversationContext(
        user_id=user_id,
        user_role=user_role,
        language=BotLanguage(language),
        messages=[],
        user_data=None,
        session_id=None
    )


# ============================================
# EXEMPLE D'UTILISATION
# ============================================

async def example_usage():
    """Exemple d'utilisation du bot"""

    # Cr√©er le service bot
    bot = AIBotService(
        api_key=None,  # Pas d'API key = utilise r√©ponses pr√©-d√©finies
        model="claude-3-5-sonnet-20241022"
    )

    # Cr√©er un contexte pour un influenceur
    context = create_conversation_context(
        user_id="user-123",
        user_role="influencer",
        language="fr"
    )

    # Simuler une conversation
    messages = [
        "Bonjour!",
        "Comment cr√©er un lien d'affiliation?",
        "Quelles sont mes statistiques?",
        "Merci, au revoir!"
    ]

    for user_msg in messages:
        response, action = await bot.chat(user_msg, context)
        print(f"\nüë§ User: {user_msg}")
        print(f"ü§ñ Bot: {response}")
        if action:
            print(f"‚ö° Action: {action.action_type}")


if __name__ == "__main__":
    import asyncio
    asyncio.run(example_usage())
